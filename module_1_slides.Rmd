---
title: "Module 1: Dealing with Data"
author: ""
date: "`r Sys.Date()`"
output: 
  xaringan::moon_reader:
    lib_dir: libs
    css: [xaringan-themer.css, other.css]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

<!-- Make default font bigger -->
<style type="text/css">
.remark-slide-content {
    font-size: 30px;
    
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo=T, 
  eval = F,
  message = F, 
  warning = F, 
  comment = NA,
  R.options=list(width=120), 
  cache.rebuild=F, 
  cache=T,
  fig.align='center', 
  fig.asp = .7,
  dev = 'svg', 
  dev.args=list(bg = 'transparent')
)

library(tidyverse); library(broom); library(kableExtra); library(visibly)

kable_df <- function(..., digits=3) {
  kable(..., digits=digits) %>% 
    kable_styling(full_width = F)
}

rnd = function(x, digits = 3) arm::fround(x, digits = digits)
```

## Introduction

---
## Objects and Classes

Everything you use in R is an <span class="emph">object</span> of a certain <span class="emph">class</span>

Objects can be anything:
- a single value
- a vector of values
- a data frame/table
- a list of 1000 models

*Anything!*

```{r objects}
x = 1:3
y = 'a'
z = list(one = x, two = y)
```

---

## Data Structures

Vectors form the basis of R data structures. Two main types are atomic and lists

```{r vector}
my_vector <- c(1, 2, 3)   # standard vector
```

```{r list}
my_list <- list(a = 1, b = 2)   # a named list
my_list
```

---

## Data frames

Data frames are a special kind of list, and probably the most commonly used for data science purposes.

```{r data_frame, eval=TRUE}
my_data = data.frame(
  id = 1:3,
  name = c('Vernon', 'Ace', 'Cora')
)

my_data
class(my_data)
```

---

## Importing Data

```{r import}
```

---

## Working with Databases

Databases must be connected to

But otherwise are used just like data frames

Not all operations will translate
- The most common ones will though
- Will work across SQL flavors
- Stay within the R world

```{r sql_connection}
library(DBI)
con <- dbConnect(RSQLite::SQLite(), ":memory:")
con

copy_to(con, mtcars, 'cars')
```

---

## Working with Databases

```{r sql_dplyr, eval=TRUE}
cars_db <- tbl(con, "cars")

# cars_db %>% 
#   filter(cyl == 8)

cars_db %>% 
  filter(cyl == 8) %>% 
  show_query()
```


---


## Using SQL directly in an R Notebook

If you already have an SQL database and want to use SQL directly, this can be done with R Markdown

```
SELECT "year", "month", 
SUM(CASE WHEN ("term_deposit" = 'yes') 
    THEN (1.0) ELSE (0.0) END) AS "subscribe",
COUNT(*) AS "total"
FROM ("bank") 
GROUP BY "year", "month"
```



---

## Data Processing 

What is the tidyverse?

The tidyverse consists of a few key packages:

- <span class="pack">ggplot2</span>: data visualization
- <span class="pack">dplyr</span>: data manipulation
- <span class="pack">tidyr</span>: data tidying
- <span class="pack">readr</span>: data import
- <span class="pack">purrr</span>: functional programming
- <span class="pack">tibble</span>: tibbles, a modern re-imagining of data frames

And of course the <span class="pack">tidyverse</span> package itself, which will load all of the above in a way that will avoid naming conflicts.

---

## Selecting Columns

```{r select}
my_data %>% 
  selct(id, var1, var2)
my_data %>% 
  selct(-var3)
```

## Select helpers

- <span class="func">starts_with</span>: starts with a prefix
- <span class="func">ends_with</span>: ends with a suffix
- <span class="func">contains</span>: contains a literal string
- <span class="func">matches</span>: matches a regular expression
- <span class="func">num_range</span>: a numerical range like x01, x02, x03.
- <span class="func">one_of</span>: variables in character vector.
- <span class="func">everything</span>: all variables.


---

## Filtering Rows

To filtering data, think of a logical statement

- Can be `TRUE` or `FALSE`

```{r filter}
my_filtered_data = mydata %>% 
  filter(x > 2)

my_filtered_data = mydata %>% 
  filter(id == 'abc')
```


---

## Generating new data

Use mutate to create a new column

```{r mutate}
mydata = mydata %>% 
  mutate(new = var1 + var2)   
```


For specific scenarios:
- <span class="func">mutate_at</span>
- <span class="func">mutate_if</span>
- <span class="func">mutate_all</span>


---

## Grouping and Summarizing Operations

A very common operation is to do things by group(s) then create new summary variables.

```{r group_by, eval=TRUE}
starwars %>% 
  group_by(species) %>% 
  summarise(height = mean(height, na.rm = T)) 
```


---

## Renaming columns

```{r rename}
mydata = mydata %>% 
  rename(first_name = id1,
         last_name  = id2)
```

Similar variants as <span class="func">mutate</span>
- <span class="func">rename_at</span>
- <span class="func">rename_if</span>
- <span class="func">rename_all</span>



---

## Merging data from different sources

Merging data can takek on a vareity of forms

Mutating Joins:
- <span class="func">left_join</span>
- <span class="func">right_join</span> 
- <span class="func">full_join</span>
- <span class="func">inner_join</span>

Filtering Joins:
- <span class="func">semi_join</span>
- <span class="func">anti_join</span>

---

## Original Data Frame

```{r origdf, out.width='100%', eval=T, echo=FALSE}
knitr::include_graphics('img/original-dfs.png')
```


---

## Left Join

> All rows from x, and all columns from x and y. Rows in x with no match in y will have NA values in the new columns.

```{r left_join, out.width='66%', eval=T, echo=FALSE}
knitr::include_graphics('img/left-join.gif')
```

---

## Left Join (extra Rows in y)

> If there are multiple matches between x and y, all combinations of the matches are returned.

```{r left_join_extra, out.width='66%', eval=T, echo=FALSE}
knitr::include_graphics('img/left-join-extra.gif')
```

---

## Right Join

> All rows from y, and all columns from x and y. Rows in y with no match in x will have NA values in the new columns.

```{r right_join, out.width='66%', eval=T, echo=FALSE}
knitr::include_graphics('img/right-join.gif')
```

---

## Full Join

> All rows and all columns from both x and y. Where there are not matching values, returns NA for the one missing.

```{r full_join, out.width='66%', eval=T, echo=FALSE}
knitr::include_graphics('img/full-join.gif')
```

---

## Inner Join

> All rows from x where there are matching values in y, and all columns from x and y.

```{r inner_join, out.width='66%', eval=T, echo=FALSE}
knitr::include_graphics('img/inner-join.gif')
```

---

## Semi Join

> All rows from x where there are matching values in y, keeping just columns from x.

```{r semi_join, out.width='66%', eval=T, echo=FALSE}
knitr::include_graphics('img/semi-join.gif')
```

---

## Anti Join

> All rows from x where there are not matching values in y, keeping just columns from x.

```{r anti_join, out.width='66%', eval=T, echo=FALSE}
knitr::include_graphics('img/anti-join.gif')
```

---


## Tidyverse

Figure credits: https://github.com/gadenbuie/tidyexplain


---

## Reshaping Data

Wide to long

Long to Wide

---

## Reshaping Data

```{r reshape_df, out.width='66%', eval=T, echo=FALSE}
knitr::include_graphics('img/original-dfs-tidy.png')
```

---

## Reshaping Data

```{r spread_gather, out.width='66%', eval=T, echo=FALSE}
knitr::include_graphics('img/tidyr-spread-gather.gif')
```

---

## Benefits of long data

More 'tidy'

Easier visualizations

Assumed for many common models

---

## Caveat

The next major release of tidyr will change approach

More flexible, consistent

- <span class="func">pivot_longer</span>
- <span class="func">pivot_wider</span>